# Deep-Learning-Collection
Adapted from the course content of Deeplearning.ai's online course, Deep Learning, this repository contains implementations of several common deep neural network (DNN) architectures. The goal is to provide a comprehensive collection of well-documented and easy-to-use models for educational and research purposes. Each model includes detailed explanations and code examples to facilitate understanding and practical use.

Directory | Description
:- | :-
[1. Logistic Regression](https://github.com/r95222023/Deep-Learning-Collection/tree/main/1.%20Logistic%20regression) | Build  a logistic regression classifier from scratch, incorporating forward and backward propagation, a cost function, and gradient descent, to recognize cats.
[2. Classification with One Hidden Layer](https://github.com/r95222023/Deep-Learning-Collection/tree/main/2.%20Classification%20with%20One%20Hidden%20Layer) | Demonstrate the construction of a neural network with a single hidden layer for 2-class classification. The objectives include implementing non-linear activation functions like tanh, computing cross-entropy loss, and executing forward and backward propagation, highlighting the differences from a basic logistic regression model.
[3. Building Deep Neural Network](https://github.com/r95222023/Deep-Learning-Collection/tree/main/3.%20Building%20Deep%20Neural%20Network) |Construct a deep neural network from scratch for image classification. The objectives include implementing non-linear units like ReLU, building a network with multiple hidden layers, and developing an easy-to-use neural network class.
[4. Deep Neural Network for Image Classification](https://github.com/r95222023/Deep-Learning-Collection/tree/main/4.%20Deep%20Neural%20Network%20for%20Image%20Classification) | Build and train a deep L-layer neural network for a cat/not-a-cat classifier, leveraging functions from previous work to improve accuracy over earlier logistic regression models. The network is applied to supervised learning tasks.
[5. Initialization](https://github.com/r95222023/Deep-Learning-Collection/tree/main/5.%20Initialization) | Explore various methods for initializing neural network weights, including random, zeros, and He initialization. It demonstrates how the choice of proper initialization can accelerate convergence and improve training and generalization outcomes.
[6. Gradient Checking](https://github.com/r95222023/Deep-Learning-Collection/tree/main/6.%20Gradient%20Checking) | Demonstrate the use of gradient checking to verify the accuracy of a backpropagation implementation, ensuring correctness and helping to identify potential bugs.
[7. Regularization](https://github.com/r95222023/Deep-Learning-Collection/tree/main/7.%20Regularization) | Implement regularization techniques to improve the generalization of deep learning models. These models, due to their high flexibility and capacity, are prone to overfitting, particularly with limited training data, which can lead to poor performance on new, unseen examples.
[8. Optimization Methods](https://github.com/r95222023/Deep-Learning-Collection/tree/main/8.%20Optimization%20Methods) | Explore advanced optimization methods like Gradient Descent, Momentum, RMSProp, and Adam to accelerate learning and improve cost function results. It demonstrates how these techniques, along with random minibatches, can significantly reduce training time and enhance model performance.
[9. Convolution Model](https://github.com/r95222023/Deep-Learning-Collection/tree/main/9.%20Convolution%20Model) | Demonstrate how to implement convolutional and pooling layers using numpy, covering both forward and optional backward propagation. It aims to explain the convolution operation, apply various pooling methods, identify key components of convolutional neural networks (such as padding, stride, and filters), and ultimately build a convolutional neural network.
[10. Convolution Model/ Mood Classifier](https://github.com/r95222023/Deep-Learning-Collection/tree/main/10.%20Convolution%20Model%3A%20Mood%20Classifier) | Involve creating a mood classifier with TensorFlow's Keras Sequential API and a ConvNet for sign language digit recognition using the Keras Functional API. Objectives include building and training ConvNets for binary and multiclass classification problems and explaining the different use cases for the Sequential and Functional APIs.
[11. Transfer Learning with MobileNet](https://github.com/r95222023/Deep-Learning-Collection/tree/main/11.%20Transfer%20Learning%20with%20MobileNet) | Explore transfer learning by adapting a pre-trained MobileNetV2 model to build a binary Alpaca classifier. MobileNetV2, known for its efficiency and trained on the ImageNet dataset, serves as the foundation for this task.
[12. Residual Networks](https://github.com/r95222023/Deep-Learning-Collection/tree/main/12.%20Residual%20Networks) | Construct a deep convolutional network using Residual Networks (ResNets) to tackle the challenges of training very deep networks. The objectives include implementing ResNet building blocks in Keras, combining them to develop a state-of-the-art image classification network, and integrating skip connections to enhance performance.
[13. Autonomous driving application Car detection](https://github.com/r95222023/Deep-Learning-Collection/tree/main/13.%20Autonomous%20driving%20application%20Car%20detection) | Implement object detection using the YOLO model, a powerful tool for real-time object detection. The objectives include detecting objects in a car detection dataset, applying non-max suppression to enhance accuracy, calculating intersection over union, and managing bounding boxes for image annotation.
[14. Image Segmentation Unet](https://github.com/r95222023/Deep-Learning-Collection/tree/main/14.%20Image%20Segmentation%20Unet) | Build a U-Net, a Convolutional Neural Network (CNN) specialized for accurate and fast image segmentation. The U-Net will be employed to perform semantic segmentation on a self-driving car dataset, predicting a label for each pixel in an image.
[15. Face Recognition](https://github.com/r95222023/Deep-Learning-Collection/tree/main/15.%20Face%20Recognition) | Builds a face recognition system. Many of the ideas presented here are from [FaceNet](https://arxiv.org/pdf/1503.03832.pdf).
[16. Art Generation with Neural Style Transfer](https://github.com/r95222023/Deep-Learning-Collection/tree/main/16.%20Art%20Generation%20with%20Neural%20Style%20Transfer) | Explore Neural Style Transfer, an algorithm introduced by [Gatys et al. (2015)](https://arxiv.org/abs/1508.06576), which transforms images to blend artistic styles with content. The objectives include implementing the neural style transfer algorithm, generating unique artistic images, and defining both the style and content cost functions for this technique.
[17. Recurrent Neural Network and LSTM](https://github.com/r95222023/Deep-Learning-Collection/tree/main/17.%20Recurrent%20Neural%20Network%20and%20LSTM) |  Build a Recurrent Neural Network (RNN) using NumPy. Key objectives include defining the notation for sequence models, describing the architecture of a basic RNN, identifying components of an LSTM, and implementing backpropagation through time for both RNNs and LSTMs. Additionally, various types of RNNs are illustrated through examples.
[18. Language Model](https://github.com/r95222023/Deep-Learning-Collection/tree/main/18.%20Language%20Model) | Build a character-level language model to generate dinosaur names and articles in the style of Shakespeare, using patterns from a dataset. Objectives include using an RNN for text processing and generation, sampling sequences, and addressing gradient issues with gradient clipping.
[19. Improvise a Jazz Solo with an LSTM Network](https://github.com/r95222023/Deep-Learning-Collection/tree/main/19.%20Improvise%20a%20Jazz%20Solo%20with%20an%20LSTM%20Network) | Implement an LSTM-based model for generating jazz music, allowing users to listen to the created compositions. The objectives are to apply LSTM for music generation, create jazz pieces with deep learning, and use the Functional API for building complex models.
[20. Word Vectors](https://github.com/r95222023/Deep-Learning-Collection/tree/main/20.%20Word%20Vectors) | Explore the use of pre-trained word embeddings for analysis and modification. This guide demonstrates how embeddings represent word relationships, including steps for loading pre-trained vectors, measuring similarity using cosine similarity, and solving word analogy problems such as "Man is to Woman as King is to ______." The notebook also tackles the issue of reducing gender bias in embeddings, an important aspect of machine learning.
[21. Emojify Word Embedding](https://github.com/r95222023/Deep-Learning-Collection/tree/main/21.%20Emojify%20Word%20Embedding) | Utilizes word vector representations to create an Emojifier, which automatically generates emojis for a given sentence. For instance, it can change "Congratulations on the promotion! Let's get coffee and talk. Love you!" into "Congratulations on the promotion! üëç Let's get coffee and talk. ‚òïÔ∏è Love you! ‚ù§Ô∏è"
[22. Translation with attention](https://github.com/r95222023/Deep-Learning-Collection/tree/main/22.%20Translation%20with%20attention) | Build a Neural Machine Translation (NMT) model to convert human-readable dates (e.g., "25th of June, 2009") into machine-readable formats (e.g., "2009-06-25"). The goal is to leverage an attention model, a refined sequence-to-sequence approach, to facilitate this translation.
[23. Trigger Word Detection](https://github.com/r95222023/Deep-Learning-Collection/tree/main/23.%20Trigger%20Word%20Detection) | Apply deep learning to speech recognition by developing a trigger word detection system. The goal is to create a speech dataset and implement an algorithm to detect a specific word‚Äî"activate"‚Äîwhich will prompt a "chiming" sound when recognized.
[24. Transformer](https://github.com/r95222023/Deep-Learning-Collection/tree/main/24.%20Transformer) | Explore the Transformer architecture, which speeds up training and excels in handling sequential data for NLP. Introduced in the 2017 paper "Attention Is All You Need," Transformers are essential for modern NLP models. Objectives include developing positional encodings, computing self-attention, implementing masked multi-head attention, and training a Transformer model.
[25. Embedding & Positional Encoding](https://github.com/r95222023/Deep-Learning-Collection/tree/main/25.%20Embedding%20%26%20Positional%20Encoding) | Examine pre-processing methods for raw text before it enters the encoder and decoder blocks of the Transformer architecture. Objectives include creating visualizations to understand positional encodings and demonstrating their impact on word embeddings.
[26. Transformer Application NER](https://github.com/r95222023/Deep-Learning-Collection/tree/main/26.%20Transformer%20Application%20NER) | Explore using the previously built Transformer architecture for Named-Entity Recognition (NER). Objectives include employing tokenizers and pre-trained models from the HuggingFace Library and fine-tuning a Transformer model specifically for NER tasks.
[27. Transformer Application QA](https://github.com/r95222023/Deep-Learning-Collection/tree/main/27.%20Transformer%20Application%20QA) | This project explores applying the previously built Transformer architecture to Question Answering (QA), a core function of Large Language Models like GPT-4. Objectives include performing extractive QA, fine-tuning a pre-trained Transformer model on a custom dataset, and implementing the QA model in both TensorFlow and PyTorch.